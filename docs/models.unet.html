---

title: Unet Architecture


keywords: fastai
sidebar: home_sidebar

summary: "A deep dive into Unet architecture in Pytorch."
description: "A deep dive into Unet architecture in Pytorch."
nb_path: "nbs/05_models.unet.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/05_models.unet.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Unet architecture from the <a href="https://github.com/qubvel/segmentation_models.pytorch">segmentation_models.pytorch</a> repository.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="Model" class="doc_header"><code>class</code> <code>Model</code><a href="https://github.com/marcomatteo/steel_segmentation/tree/master/steel_segmentation/models/unet.py#L19" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>Model</code>() :: <code>Module</code></p>
</blockquote>
<p>Base class for all neural network modules.</p>
<p>Your models should also subclass this class.</p>
<p>Modules can also contain other Modules, allowing to nest them in
a tree structure. You can assign the submodules as regular attributes::</p>

<pre><code>import torch.nn as nn
import torch.nn.functional as F

class Model(nn.Module):
    def __init__(self):
        super(Model, self).__init__()
        self.conv1 = nn.Conv2d(1, 20, 5)
        self.conv2 = nn.Conv2d(20, 20, 5)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        return F.relu(self.conv2(x))

</code></pre>
<p>Submodules assigned in this way will be registered, and will have their
parameters converted too when you call :meth:<code>to</code>, etc.</p>
<p>:ivar training: Boolean represents whether this module is in training or
                evaluation mode.
:vartype training: bool</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Custom <code>nn.Module</code> class with <code>kaiming_normal_</code> initialization. This class look into <code>self.modules</code> and if it's a <code>nn.BatchNorm2d</code> init with 1 the weights and 0 the biases.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="Conv2dReLU" class="doc_header"><code>class</code> <code>Conv2dReLU</code><a href="https://github.com/marcomatteo/steel_segmentation/tree/master/steel_segmentation/models/unet.py#L34" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>Conv2dReLU</code>(<strong><code>in_channels</code></strong>, <strong><code>out_channels</code></strong>, <strong><code>kernel_size</code></strong>, <strong><code>padding</code></strong>=<em><code>0</code></em>, <strong><code>stride</code></strong>=<em><code>1</code></em>, <strong><code>use_batchnorm</code></strong>=<em><code>True</code></em>, <strong>**<code>batchnorm_params</code></strong>) :: <code>Module</code></p>
</blockquote>
<p>Base class for all neural network modules.</p>
<p>Your models should also subclass this class.</p>
<p>Modules can also contain other Modules, allowing to nest them in
a tree structure. You can assign the submodules as regular attributes::</p>

<pre><code>import torch.nn as nn
import torch.nn.functional as F

class Model(nn.Module):
    def __init__(self):
        super(Model, self).__init__()
        self.conv1 = nn.Conv2d(1, 20, 5)
        self.conv2 = nn.Conv2d(20, 20, 5)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        return F.relu(self.conv2(x))

</code></pre>
<p>Submodules assigned in this way will be registered, and will have their
parameters converted too when you call :meth:<code>to</code>, etc.</p>
<p>:ivar training: Boolean represents whether this module is in training or
                evaluation mode.
:vartype training: bool</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> 
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">gv</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;Conv2d-&gt;BatchNorm-&gt;ReLU&#39;&#39;&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_svg output_subarea output_execute_result">
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.42.3 (20191010.1750)
 -->
<!-- Title: G Pages: 1 -->
<svg width="375pt" height="44pt"
 viewBox="0.00 0.00 375.07 44.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 40)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-40 371.07,-40 371.07,4 -4,4"/>
<!-- Conv2d -->
<g id="node1" class="node">
<title>Conv2d</title>
<ellipse fill="none" stroke="black" cx="46.15" cy="-18" rx="46.29" ry="18"/>
<text text-anchor="middle" x="46.15" y="-14.3" font-family="Times,serif" font-size="14.00">Conv2d</text>
</g>
<!-- BatchNorm -->
<g id="node2" class="node">
<title>BatchNorm</title>
<ellipse fill="none" stroke="black" cx="193.29" cy="-18" rx="64.99" ry="18"/>
<text text-anchor="middle" x="193.29" y="-14.3" font-family="Times,serif" font-size="14.00">BatchNorm</text>
</g>
<!-- Conv2d&#45;&gt;BatchNorm -->
<g id="edge1" class="edge">
<title>Conv2d&#45;&gt;BatchNorm</title>
<path fill="none" stroke="black" d="M92.67,-18C100.74,-18 109.32,-18 117.94,-18"/>
<polygon fill="black" stroke="black" points="118.05,-21.5 128.05,-18 118.05,-14.5 118.05,-21.5"/>
</g>
<!-- ReLU -->
<g id="node3" class="node">
<title>ReLU</title>
<ellipse fill="none" stroke="black" cx="330.68" cy="-18" rx="36.29" ry="18"/>
<text text-anchor="middle" x="330.68" y="-14.3" font-family="Times,serif" font-size="14.00">ReLU</text>
</g>
<!-- BatchNorm&#45;&gt;ReLU -->
<g id="edge2" class="edge">
<title>BatchNorm&#45;&gt;ReLU</title>
<path fill="none" stroke="black" d="M258.41,-18C267.06,-18 275.79,-18 284.03,-18"/>
<polygon fill="black" stroke="black" points="284.16,-21.5 294.16,-18 284.16,-14.5 284.16,-21.5"/>
</g>
</g>
</svg>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="DecoderBlock" class="doc_header"><code>class</code> <code>DecoderBlock</code><a href="https://github.com/marcomatteo/steel_segmentation/tree/master/steel_segmentation/models/unet.py#L56" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>DecoderBlock</code>(<strong><code>in_channels</code></strong>, <strong><code>out_channels</code></strong>, <strong><code>use_batchnorm</code></strong>=<em><code>True</code></em>) :: <code>Module</code></p>
</blockquote>
<p>Base class for all neural network modules.</p>
<p>Your models should also subclass this class.</p>
<p>Modules can also contain other Modules, allowing to nest them in
a tree structure. You can assign the submodules as regular attributes::</p>

<pre><code>import torch.nn as nn
import torch.nn.functional as F

class Model(nn.Module):
    def __init__(self):
        super(Model, self).__init__()
        self.conv1 = nn.Conv2d(1, 20, 5)
        self.conv2 = nn.Conv2d(20, 20, 5)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        return F.relu(self.conv2(x))

</code></pre>
<p>Submodules assigned in this way will be registered, and will have their
parameters converted too when you call :meth:<code>to</code>, etc.</p>
<p>:ivar training: Boolean represents whether this module is in training or
                evaluation mode.
:vartype training: bool</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Up sample the inputs by a <code>scale_factor</code> of 2 with <code>'nearest'</code>, if a <code>skip</code> connection is provided then concatenates with the inputs and then do a double <a href="/steel_segmentation/models.unet.html#Conv2dReLU"><code>Conv2dReLU</code></a>.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="CenterBlock" class="doc_header"><code>class</code> <code>CenterBlock</code><a href="https://github.com/marcomatteo/steel_segmentation/tree/master/steel_segmentation/models/unet.py#L75" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>CenterBlock</code>(<strong><code>in_channels</code></strong>, <strong><code>out_channels</code></strong>, <strong><code>use_batchnorm</code></strong>=<em><code>True</code></em>) :: <a href="/steel_segmentation/models.unet.html#DecoderBlock"><code>DecoderBlock</code></a></p>
</blockquote>
<p>Base class for all neural network modules.</p>
<p>Your models should also subclass this class.</p>
<p>Modules can also contain other Modules, allowing to nest them in
a tree structure. You can assign the submodules as regular attributes::</p>

<pre><code>import torch.nn as nn
import torch.nn.functional as F

class Model(nn.Module):
    def __init__(self):
        super(Model, self).__init__()
        self.conv1 = nn.Conv2d(1, 20, 5)
        self.conv2 = nn.Conv2d(20, 20, 5)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        return F.relu(self.conv2(x))

</code></pre>
<p>Submodules assigned in this way will be registered, and will have their
parameters converted too when you call :meth:<code>to</code>, etc.</p>
<p>:ivar training: Boolean represents whether this module is in training or
                evaluation mode.
:vartype training: bool</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>A double <a href="/steel_segmentation/models.unet.html#Conv2dReLU"><code>Conv2dReLU</code></a> without up sampling.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="EncoderDecoder" class="doc_header"><code>class</code> <code>EncoderDecoder</code><a href="https://github.com/marcomatteo/steel_segmentation/tree/master/steel_segmentation/models/unet.py#L81" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>EncoderDecoder</code>(<strong><code>encoder</code></strong>, <strong><code>decoder</code></strong>, <strong><code>activation</code></strong>) :: <a href="/steel_segmentation/models.unet.html#Model"><code>Model</code></a></p>
</blockquote>
<p>Base class for all neural network modules.</p>
<p>Your models should also subclass this class.</p>
<p>Modules can also contain other Modules, allowing to nest them in
a tree structure. You can assign the submodules as regular attributes::</p>

<pre><code>import torch.nn as nn
import torch.nn.functional as F

class Model(nn.Module):
    def __init__(self):
        super(Model, self).__init__()
        self.conv1 = nn.Conv2d(1, 20, 5)
        self.conv2 = nn.Conv2d(20, 20, 5)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        return F.relu(self.conv2(x))

</code></pre>
<p>Submodules assigned in this way will be registered, and will have their
parameters converted too when you call :meth:<code>to</code>, etc.</p>
<p>:ivar training: Boolean represents whether this module is in training or
                evaluation mode.
:vartype training: bool</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> 
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> 
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> 
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="UnetDecoder" class="doc_header"><code>class</code> <code>UnetDecoder</code><a href="https://github.com/marcomatteo/steel_segmentation/tree/master/steel_segmentation/models/unet.py#L127" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>UnetDecoder</code>(<strong><code>encoder_channels</code></strong>, <strong><code>decoder_channels</code></strong>=<em><code>(256, 128, 64, 32, 16)</code></em>, <strong><code>final_channels</code></strong>=<em><code>1</code></em>, <strong><code>use_batchnorm</code></strong>=<em><code>True</code></em>, <strong><code>center</code></strong>=<em><code>False</code></em>) :: <a href="/steel_segmentation/models.unet.html#Model"><code>Model</code></a></p>
</blockquote>
<p>Base class for all neural network modules.</p>
<p>Your models should also subclass this class.</p>
<p>Modules can also contain other Modules, allowing to nest them in
a tree structure. You can assign the submodules as regular attributes::</p>

<pre><code>import torch.nn as nn
import torch.nn.functional as F

class Model(nn.Module):
    def __init__(self):
        super(Model, self).__init__()
        self.conv1 = nn.Conv2d(1, 20, 5)
        self.conv2 = nn.Conv2d(20, 20, 5)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        return F.relu(self.conv2(x))

</code></pre>
<p>Submodules assigned in this way will be registered, and will have their
parameters converted too when you call :meth:<code>to</code>, etc.</p>
<p>:ivar training: Boolean represents whether this module is in training or
                evaluation mode.
:vartype training: bool</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Decoder part of a Unet.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="ResNetEncoder" class="doc_header"><code>class</code> <code>ResNetEncoder</code><a href="https://github.com/marcomatteo/steel_segmentation/tree/master/steel_segmentation/models/unet.py#L191" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>ResNetEncoder</code>(<strong>*<code>args</code></strong>, <strong>**<code>kwargs</code></strong>) :: <code>ResNet</code></p>
</blockquote>
<p>Base class for all neural network modules.</p>
<p>Your models should also subclass this class.</p>
<p>Modules can also contain other Modules, allowing to nest them in
a tree structure. You can assign the submodules as regular attributes::</p>

<pre><code>import torch.nn as nn
import torch.nn.functional as F

class Model(nn.Module):
    def __init__(self):
        super(Model, self).__init__()
        self.conv1 = nn.Conv2d(1, 20, 5)
        self.conv2 = nn.Conv2d(20, 20, 5)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        return F.relu(self.conv2(x))

</code></pre>
<p>Submodules assigned in this way will be registered, and will have their
parameters converted too when you call :meth:<code>to</code>, etc.</p>
<p>:ivar training: Boolean represents whether this module is in training or
                evaluation mode.
:vartype training: bool</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Encoder part of a Unet.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="preprocess_input" class="doc_header"><code>preprocess_input</code><a href="https://github.com/marcomatteo/steel_segmentation/tree/master/steel_segmentation/models/unet.py#L274" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>preprocess_input</code>(<strong><code>x</code></strong>, <strong><code>mean</code></strong>=<em><code>None</code></em>, <strong><code>std</code></strong>=<em><code>None</code></em>, <strong><code>input_space</code></strong>=<em><code>'RGB'</code></em>, <strong><code>input_range</code></strong>=<em><code>None</code></em>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>
<p>Preprocessing the <code>x</code> inputs with normalization.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="get_encoder" class="doc_header"><code>get_encoder</code><a href="https://github.com/marcomatteo/steel_segmentation/tree/master/steel_segmentation/models/unet.py#L294" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>get_encoder</code>(<strong><code>name</code></strong>, <strong><code>encoder_weights</code></strong>=<em><code>None</code></em>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="get_encoder_names" class="doc_header"><code>get_encoder_names</code><a href="https://github.com/marcomatteo/steel_segmentation/tree/master/steel_segmentation/models/unet.py#L306" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>get_encoder_names</code>()</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="get_preprocessing_fn" class="doc_header"><code>get_preprocessing_fn</code><a href="https://github.com/marcomatteo/steel_segmentation/tree/master/steel_segmentation/models/unet.py#L310" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>get_preprocessing_fn</code>(<strong><code>encoder_name</code></strong>, <strong><code>pretrained</code></strong>=<em><code>'imagenet'</code></em>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="Unet" class="doc_header"><code>class</code> <code>Unet</code><a href="https://github.com/marcomatteo/steel_segmentation/tree/master/steel_segmentation/models/unet.py#L325" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>Unet</code>(<strong><code>encoder_name</code></strong>=<em><code>'resnet34'</code></em>, <strong><code>encoder_weights</code></strong>=<em><code>'imagenet'</code></em>, <strong><code>decoder_use_batchnorm</code></strong>=<em><code>True</code></em>, <strong><code>decoder_channels</code></strong>=<em><code>(256, 128, 64, 32, 16)</code></em>, <strong><code>classes</code></strong>=<em><code>1</code></em>, <strong><code>activation</code></strong>=<em><code>'sigmoid'</code></em>, <strong><code>center</code></strong>=<em><code>False</code></em>) :: <a href="/steel_segmentation/models.unet.html#EncoderDecoder"><code>EncoderDecoder</code></a></p>
</blockquote>
<p>Unet_ is a fully convolution neural network for image semantic segmentation</p>
<p>Args:
    encoder_name: name of classification model (without last dense layers) used as feature
        extractor to build segmentation model.
    encoder_weights: one of <code>None</code> (random initialization), <code>imagenet</code> (pre-training on ImageNet).
    decoder_channels: list of numbers of <code>Conv2D</code> layer filters in decoder blocks
    decoder_use_batchnorm: if <code>True</code>, <code>BatchNormalisation</code> layer between <code>Conv2D</code> and <code>Activation</code> layers
        is used.
    classes: a number of classes for output (output shape - <code>(batch, classes, h, w)</code>).
    activation: activation function used in <code>.predict(x)</code> method for inference.
        One of [<code>sigmoid</code>, <code>softmax</code>, callable, None]
    center: if <code>True</code> add <code>Conv2dReLU</code> block on encoder head (useful for VGG models)</p>
<p>Returns:
    <code>torch.nn.Module</code>: <strong>Unet</strong></p>
<p>Paper:
<a href="https://arxiv.org/pdf/1505.04597">https://arxiv.org/pdf/1505.04597</a></p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> 
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

</div>
 

