# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01_metadata.ipynb (unless otherwise specified).

__all__ = ['curr_dir_name', 'path', 'print_competition_data', 'train_path', 'train_pfiles', 'test_path', 'test_pfiles',
           'models_dir', 'pred_path', 'sub_path', 'get_train_df', 'SteelMeta', 'steel_meta', 'hard_neg_patterns',
           'train', 'train_all', 'train_pivot', 'get_classification_df', 'train_multi', 'test_df']

# Cell
import warnings
warnings.filterwarnings("ignore")

from fastai.vision.all import *
import pandas as pd
import os

# Cell
curr_dir_name = Path(os.getcwd()).name
path = Path('data/')

if not path.is_dir():
    path = Path("../data/")

# Cell
def print_competition_data(p: Path = path):
    for elem in p.ls():
        print(elem)

# Cell
# train images
train_path = path/"train_images"
train_pfiles = get_image_files(train_path) if train_path.is_dir() else L([])
# test images
test_path = path/"test_images"
test_pfiles = get_image_files(test_path) if train_path.is_dir() else L([])
# dl models
models_dir = path.parent / "models"
# mask predictions
pred_path = path / "predictions"
pred_path.mkdir(parents=True, exist_ok=True)
# submissions
sub_path = path / "submissions"
sub_path.mkdir(parents=True, exist_ok=True)

# Cell
def get_train_df(only_faulty=False):
    """
    Get training DataFrame with all the images in data/train_images.
    Returns only the faulty images if `only_faulty`.
    """
    train = pd.read_csv(path/"train.csv")
    train["ImageId_ClassId"] = train["ImageId"] + \
        "_" + train["ClassId"].astype('str')
    if only_faulty:
        return train

    img_names = [img_path.name for img_path in train_pfiles]
    df_all = pd.DataFrame({'ImageId': img_names})
    train_all = pd.merge(df_all, train, on="ImageId",
                         how="outer", indicator=True)
    # Renaming and fillna
    train_all.rename(columns={'_merge': 'status'}, inplace=True)
    rename_dict = {"both": "faulty", "left_only": "no_faulty"}
    train_all["status"] = train_all["status"].cat.rename_categories(
        rename_dict)
    train_all.ClassId.fillna(0, inplace=True)
    train_all.ClassId = train_all.ClassId.astype('int64')
    train_all.EncodedPixels.fillna(-1, inplace=True)

    return train_all

# Cell
class SteelMeta:

    def __init__(self): pass

    @property
    def hard_neg_with_patterns(self):
        try:
            df = pd.read_csv(path/"hard_negatives_patterns.txt",
                             header=None, names=["ImageId"])
        except:
            df = pd.DataFrame()
        return df

    @property
    def train(self):
        try:
            df = get_train_df(only_faulty=True)
        except:
            df = pd.DataFrame()
        return df

    @property
    def train_all(self):
        try:
            df = get_train_df()
        except:
            df = pd.DataFrame()
        return df

    @property
    def train_pivot(self):
        def get_train_pivot():
            """
            Summarize the training csv with ClassId as columns and values EncodedPixels
            """
            train_pivot = self.train_all.pivot(
                index="ImageId", columns="ClassId", values="EncodedPixels")
            train_pivot["n"] = train_pivot.notnull().sum(1)
            return train_pivot

        try:
            df = get_train_pivot()
        except:
            df = pd.DataFrame()
        return df

    @property
    def train_multi(self):
        def get_classification_df():
            """
            Get the DataFrame for the multiclass classification model
            """

            def assign_multi_ClassId(x):
                """Returns a string with multi ClassId sep with a blank space (' ')"""
                def fill_cols(c):
                    return c.fillna(5).astype('int64').astype(str)

                cols = [fill_cols(x[i]) for i in range(5)]
                cols = [col.replace('5', '') for col in cols]
                ClassId_multi = cols[0] + " " + cols[1] + " " + \
                    cols[2] + " " + cols[3] + " " + cols[4]
                ClassId_multi = ClassId_multi.str.strip()
                ClassId_multi = ClassId_multi.str.replace('  ', ' ')

                return ClassId_multi.str.strip()

            train_multi = self.train_all.pivot(
                index="ImageId", columns="ClassId", values="ClassId")
            train_multi = train_multi.assign(
                ClassId_multi=lambda x: assign_multi_ClassId(x))
            return train_multi.reset_index()[["ImageId", "ClassId_multi"]]
        try:
            df = get_classification_df()
        except:
            df = pd.DataFrame()
        return df

    @property
    def test_df(self):
        try:
            df = pd.read_csv(path / 'sample_submission.csv')
        except:
            df = pd.DataFrame()
        return df

steel_meta = SteelMeta()

# Cell
hard_neg_patterns = steel_meta.hard_neg_with_patterns

# Cell
train = steel_meta.train

# Cell
train_all = steel_meta.train_all

# Cell
train_pivot = steel_meta.train_pivot

# Cell
def get_classification_df(df: pd.DataFrame = None):
    """
    Get the DataFrame for the multiclass classification model
    """

    def assign_multi_ClassId(x):
        """Returns a string with multi ClassId sep with a blank space (' ')"""
        def fill_cols(c):
            return c.fillna(5).astype('int64').astype(str)

        cols = [fill_cols(x[i]) for i in range(5)]
        cols = [col.replace('5', '') for col in cols]
        ClassId_multi = cols[0] + " " + cols[1] + " " + \
            cols[2] + " " + cols[3] + " " + cols[4]
        ClassId_multi = ClassId_multi.str.strip()
        ClassId_multi = ClassId_multi.str.replace('  ', ' ')

        return ClassId_multi.str.strip()

    if not df:
        df = train_all
    train_multi = df.pivot(
        index="ImageId", columns="ClassId", values="ClassId")
    train_multi = train_multi.assign(
        ClassId_multi=lambda x: assign_multi_ClassId(x))
    return train_multi.reset_index()[["ImageId", "ClassId_multi"]]

# Cell
train_multi = steel_meta.train_multi

# Cell
test_df = steel_meta.test_df