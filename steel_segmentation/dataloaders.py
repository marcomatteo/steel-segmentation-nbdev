# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/04_dataloaders.ipynb (unless otherwise specified).

__all__ = ['get_classification_dls', 'AlbumentationsTransform', 'get_train_aug', 'get_valid_aug', 'SteelMaskBlock',
           'get_segmentation_dls', 'get_segmentation_dls_from_df', 'get_train_dls']

# Cell
from .metadata import *
from .masks import *
from .datasets import *

from fastcore.test import *
from fastai.vision.all import *

from collections import defaultdict
from matplotlib import pyplot as plt
import torch

import pandas as pd
import numpy as np
import os

from sklearn.model_selection import train_test_split
from torch.utils.data import DataLoader
import albumentations as alb

# Cell
def get_classification_dls(bs, with_tfms: bool = True, size=None, seed=42):
    """
    Dataloaders from train DataFrame
    """
    b_tfms = [Normalize.from_stats(*imagenet_stats)]

    if with_tfms:
        b_tfms += aug_transforms(
            size=size if size else (256, 1600),
            max_warp=.1,
            max_rotate=5.,
            max_lighting=0.1)

    dblock = DataBlock(
        blocks=(ImageBlock, MultiCategoryBlock()),
        get_x=ColReader(0, pref=train_path),
        get_y=ColReader(1, label_delim=' '),
        splitter=RandomSplitter(valid_pct=0.2, seed=seed),
        batch_tfms=b_tfms)

    return dblock.dataloaders(train_multi, bs=bs)

# Cell
class AlbumentationsTransform(RandTransform):
    "A transform handler for multiple `Albumentation` transforms"
    split_idx,order=None,2
    def __init__(self, train_aug, valid_aug): store_attr()

    def before_call(self, b, split_idx):
        self.idx = split_idx

    def encodes(self, img: PILImage):
        if self.idx == 0:
            aug_img = self.train_aug(image=np.array(img))['image']
        else:
            aug_img = self.valid_aug(image=np.array(img))['image']
        return PILImage.create(aug_img)

    def encodes(self, mask: PILMask):
        if self.idx == 0:
            aug_mask = self.train_aug(mask=np.array(mask))['mask']
        else:
            aug_mask = self.valid_aug(mask=np.array(mask))['mask']
        return PILMask.create(aug_mask)

# Cell
def get_train_aug(): return alb.Compose([
    alb.OneOf([
        alb.VerticalFlip(p=0.5),
        alb.HorizontalFlip(p=0.5)], p=0.8),
    alb.RandomRotate90(p=0.5),
    alb.OneOf([
        alb.ElasticTransform(p=0.5, alpha=120, sigma=120 * 0.05, alpha_affine=120 * 0.03),
        alb.GridDistortion(p=0.5),
        alb.OpticalDistortion(distort_limit=1, shift_limit=0.5, p=1),
    ], p=0.8),
    alb.CropNonEmptyMaskIfExists(256, 400, p=1.)
])

def get_valid_aug(): return alb.Compose([alb.RandomCrop(256, 400)])

# Cell
def SteelMaskBlock(codes=None):
    return TransformBlock(type_tfms=[MakeMask,PILMask.create],
                          item_tfms=AddMaskCodes(codes),
                          batch_tfms=[IntToFloatTensor, ChannelMask])

# Cell
def get_segmentation_dls(bs, size, with_btfms=True, seed=42):
    """Dataloaders from `train_path` folder"""

    b_tfms = [Normalize.from_stats(*imagenet_stats)]

    if with_btfms:
        b_tfms += aug_transforms(
            size=size if size else (256, 1600),
            max_warp=.1,
            max_rotate=5.,
            max_lighting=0.1)

    def get_labels_from_img(p):
        return labels_path/f'{p.stem}_P.png'

    dblock = DataBlock(
        blocks=(ImageBlock, MaskBlock(codes=classes)),
        get_items=get_image_files,
        get_y=get_labels_from_img,
        splitter=RandomSplitter(valid_pct=0.2, seed=seed),
        batch_tfms=b_tfms)

    return dblock.dataloaders(train_path, bs=bs)

# Cell
def get_segmentation_dls_from_df(train_df, bs, size, with_btfms=True, seed=42):
    """Dataloaders from `train` DataFrame"""
    def get_x(df):
        img_name = df["ImageId"]
        return train_path / str(img_name)

    def get_y(df):
        img_name = df["ImageId"].split(".")[0] + "_P.png"
        return labels_path / img_name

    b_tfms = [Normalize.from_stats(*imagenet_stats)]

    if with_btfms:
        b_tfms += aug_transforms(
            size=size if size else (256, 1600),
            max_warp=.1,
            max_rotate=5.,
            max_lighting=0.1)

    dblock = DataBlock(
        blocks=(ImageBlock, MaskBlock(codes=classes)),
        get_x=get_x,
        get_y=get_y,
        splitter=RandomSplitter(valid_pct=0.2, seed=seed),
        batch_tfms=b_tfms)

    return dblock.dataloaders(train_df, bs=bs)

# Cell
def get_train_dls(
        phase,
        mean=None,
        std=None,
        batch_size=8,
        num_workers=4,
    ):
    '''Returns dataloader for the model training.'''
    df = train_pivot
    if (mean is None) or (std is None):
        mean, std = imagenet_stats

    train_df, val_df = train_test_split(
        df, test_size=0.2, stratify=df["n"], random_state=69)

    df = train_df if phase == "train" else val_df
    image_dataset = SteelDataset(df, mean, std, phase)

    dataloader = DataLoader(
        image_dataset,
        batch_size=batch_size,
        num_workers=num_workers,
        pin_memory=True,
        shuffle=True,
    )

    return dataloader