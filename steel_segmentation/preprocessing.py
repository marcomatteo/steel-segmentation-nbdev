# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/02_preprocessing.ipynb (unless otherwise specified).

__all__ = ['rle_to_mask', 'multi_rle_to_mask', 'img_with_mask', 'mask2rle', 'make_mask', 'create_masks', 'labels_dir']

# Cell
from .core import *
from .data import *

from fastcore.foundation import *
from fastai.vision.all import *
from PIL import Image
from collections import defaultdict
from matplotlib import pyplot as plt

import pandas as pd
import numpy as np

# Cell
def rle_to_mask(rle: str, class_id: int, height: int, width: int) -> np.ndarray:
    """
    Convert RLE encoded pixels to numpy array for only one class_id
    """
    rows, cols = height, width
    mask = np.zeros(rows*cols, dtype=np.uint8)

    if rle == -1:
        return mask.reshape(cols, rows).T

    encoded_pixels = [int(i) for i in rle.split(" ")]

    # (n, 2) as [[pos, offs], ... ]
    rle_pairs = np.array(encoded_pixels).reshape(-1, 2)

    for index, length in rle_pairs:
        index -= 1
        mask[index: (index + length)] = class_id

    mask = mask.reshape(cols, rows)
    return mask.T

# Cell
def multi_rle_to_mask(img_path: str, df: pd.DataFrame = train_all) -> np.ndarray:
    """
    Convert all RLE encoded pixels for an image and returns the mask
    """
    height, width = 256, 1600

    def build_mask(df) -> np.ndarray:
        masks = defaultdict(np.ndarray)
        for num, row in enumerate(df.itertuples()):
            masks[num] = rle_to_mask(
                row.EncodedPixels, row.ClassId, height, width)

        mask = masks.pop(0)

        items_left = len(masks)
        if items_left:
            for item in range(items_left):
                mask_to_add = masks.get(item + 1)
                mask = np.add(mask, mask_to_add)

        return mask

    img_id = img_path.name
    img_df = df.loc[df["ImageId"] == img_id]
    return build_mask(img_df)

# Cell
def img_with_mask(img_path: str):
    return np.array(Image.open(img_path)), multi_rle_to_mask(img_path)

# Cell
def mask2rle(img):
    '''
    From #https://www.kaggle.com/paulorzp/rle-functions-run-lenght-encode-decode

    Attributes: `img`: numpy array, 1 -> mask, 0 -> background.

    Returns: run length as string formated
    '''
    pixels= img.T.flatten()
    pixels = np.concatenate([[0], pixels, [0]])
    runs = np.where(pixels[1:] != pixels[:-1])[0] + 1
    runs[1::2] -= runs[::2]
    return ' '.join(str(x) for x in runs)

# Cell
def make_mask(row_id, df=train_pivot):
    '''
    Given a row index, return image_id and mask (256, 1600, 4)
    from the dataframe `df`
    '''
    fname = df.iloc[row_id].name
    labels = df.iloc[row_id][:4]

    masks = np.zeros((256, 1600, 4), dtype=np.float32) # float32 is V.Imp
    # 4:class 1～4 (ch:0～3)

    for idx, label in enumerate(labels.values):
        if label is not np.nan:
            label = label.split(" ")
            positions = map(int, label[0::2])
            length = map(int, label[1::2])
            mask = np.zeros(256 * 1600, dtype=np.uint8)
            for pos, le in zip(positions, length):
                mask[pos:(pos + le)] = 1
            masks[:, :, idx] = mask.reshape(256, 1600, order='F')

    return fname, masks

# Cell
labels_dir = path / "labels"


def create_masks(df: pd.DataFrame):
    """Create the masks for ImageId in df"""
    paths = []
    for img_id in df["ImageId"].tolist():
        img_path = train_path / img_id
        img_label = labels_dir/f"{img_path.stem}_P.png"
        if not img_label.is_file():
            mask = multi_rle_to_mask(img_path)
            im = Image.fromarray(mask)
            im.save(img_label)
        paths.append(img_label)
    return L(paths)