# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/07_model.predict.ipynb (unless otherwise specified).

__all__ = ['pred_path', 'Predict']

# Cell
from ..core import *
from ..data import *
from ..dataloaders import *
from .metrics import *
from .model import *

import fastai
from fastai.vision.all import *
from fastai.metrics import *
from fastai.data.all import *

import cv2
import pathlib
import numpy as np
import pandas as pd

pred_path = path.parent / "predictions"
pred_path.mkdir(parents=True, exist_ok=True)

# Cell
class Predict:
    pred_mask_path = pred_path / "prediction_masks"
    pred_mask_path.mkdir(parents=True, exist_ok=True)

    def __init__(self,
                 source,
                 learner,
                 source_path:pathlib.Path=None):
        self.source = source
        self.learner = learner
        self.source_path = source_path if source_path else train_path

        self.single_prediction = False

        if isinstance(self.source, pathlib.Path):
            self.img_paths = self.get_path_source_list()
        elif isinstance(self.source, pd.DataFrame):
            self.img_paths = self.get_df_source_list()
        elif isinstance(self.source, str):
            self.single_prediction = True
            self.img_paths = L(self.source_path / self.source)

        self.elems = len(self.img_paths)

    def get_df_source_list(self):
        """Load `source` if it's a DataFrame instance."""
        tfm = ColReader("ImageId", pref=self.source_path)
        return L([tfm(o) for o in self.source.itertuples()])

    def get_path_source_list(self):
        """Load `source` if it's a pathlib.Path instance."""
        return get_image_files(self.source)

    def predict(self, selected_imgs):
        """Get the predictions on the `selected_imgs`."""
        if self.single_prediction:
            pred_full_dec, pred_dec, out = self.learner.predict(selected_imgs)
            return pred_full_dec

        test_dl = self.learner.dls.test_dl(test_items=selected_imgs)
        pred_probs,_,_ = self.learner.get_preds(dl=test_dl, with_decoded=True)

        return pred_probs

    def post_process(self, probability):
        """
        Post processing of each predicted mask, components with lesser number of pixels
        than `min_size` are ignored.
        """
        mask = cv2.threshold(probability, self.threshold, 1, cv2.THRESH_BINARY)[1]
        num_component, component = cv2.connectedComponents(mask.astype(np.uint8))
        predictions = np.zeros((256, 1600), np.float32)
        num = 0
        for c in range(1, num_component):
            p = (component == c)
            if p.sum() > self.min_size:
                predictions[p] = 1
                num += 1
        return predictions, num

    def get_RLEs(self, img_names, pred_probs):
        """For each image in the batch to predict,
        returns a list of tuples with `(img_id, rle)`."""
        predictions = []

        for num_pred, t_pred in enumerate(pred_probs): # img in bs
            np_pred = t_pred.numpy()

            # iterate through class_id without class_id 0
            for class_id, prob in enumerate(np_pred[1:]):
                pred, num = self.post_process(prob)
                rle = mask2rle(pred)
                name = img_names[num_pred] + f"_{class_id+1}"
                predictions.append([name, rle])

        return pd.DataFrame(predictions, columns=['ImageId_ClassId', 'EncodedPixels'])

    def save_df(self, df, file_name):
        """Save the final DataFrame into the `pred_path` folder."""
        df.to_csv(pred_path/file_name, index=False)

    def get_predictions(self):
        """Iterate through `self.folds`, predict the mask and
        get the RLEs in a DataFrame."""
        df_preds = []

        for fold in range(self.folds):
            start, end = fold*self.size_fold, (fold+1)*self.size_fold
            print(f"From {start} to {end} of {self.elems}")

            selected_imgs = self.img_paths[start:end]

            img_names = selected_imgs.map(Path).map(lambda x: x.name)
            pred_probs = self.predict(selected_imgs)

            tmp_df = self.get_RLEs(img_names, pred_probs)
            df_preds.append(tmp_df)

            torch.cuda.empty_cache()

        if len(df_preds) == 1:
            return df_preds[0]

        df = pd.concat(df_preds, axis=0, ignore_index=True)
        return df.fillna("", inplace=True)

    def save_masks(self):
        """Iterate through the RLEs in `self.df` and save the masks."""
        rows = []
        for row in self.df.itertuples():
            if row.EncodedPixels != '':
                img_id, class_id = row.ImageId_ClassId.split("_")
                img_id = img_id.split(".")[0]
                img_label = img_id + "_pred.png"
                img_path = self.pred_mask_path / img_label

                mask = rle_to_mask(row.EncodedPixels, class_id, 256, 1600)
                im = Image.fromarray(mask)
                im.save(img_path)

                rows.append((img_id + ".jpg", class_id, img_label))
        self.df_masks = pd.DataFrame(rows, columns=['ImageId', 'ClassId', 'Mask_path'])
        return self.df_masks

    def __call__(self, size_fold:int, threshold:float, min_size:int):
        """Call the object with prediction attributes
        and return the `self.df` DataFrame with RLEs."""
        self.size_fold = min([self.elems, size_fold])
        self.threshold = threshold
        self.min_size = min_size
        self.folds = self.elems // self.size_fold
        if (self.elems % self.size_fold) != 0:
            self.folds += 1

        self.df = self.get_predictions()
        return self.df