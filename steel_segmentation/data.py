# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01_data.ipynb (unless otherwise specified).

__all__ = ['defeat_position', 'get_random_idx', 'get_perm_imgs_path', 'plot_defected_image', 'show_defects',
           'rle_to_mask', 'multi_rle_to_mask', 'img_with_mask', 'mask2rle', 'make_mask', 'create_masks', 'labels_path']

# Cell
from .core import *
from fastcore.foundation import *
from PIL import Image
from collections import defaultdict
from matplotlib import pyplot as plt
from fastcore.test import test_eq
from fastai.data.transforms import get_image_files
from fastai.vision.all import Image

import pandas as pd
import numpy as np
from pathlib import Path

# Cell
def defeat_position(img_id: str, class_id: int, df: pd.DataFrame = train):
    """
    Get coordinates of defects `(x, y)` given an ImageId and a ClassId
    """
    # Select the image to mask
    # cond = df.ImageId_ClassId == f"{img_id}_{class_id}"
    cond = (df.ImageId == img_id) & (df.ClassId == class_id)
    train_s = df[cond]

    encoded_pixels = [int(i)
                      for i in train_s.EncodedPixels.values[0].split(" ")]

    pixcels = []
    pos_pixels = encoded_pixels[0:len(encoded_pixels):2]
    offs_pixels = encoded_pixels[1:len(encoded_pixels):2]

    for pos, offset in zip(pos_pixels, offs_pixels):
        pixcels.extend(list(range(pos, pos+offset)))

    pixcels = np.array(pixcels)
    x = pixcels // 256
    y = pixcels % 256

    return x, y

# Cell
def get_random_idx(n: int) -> np.ndarray:
    """
    Return a random sequence of size `n`.
    """
    rng = np.random.default_rng()
    return rng.permutation(n)

# Cell
def get_perm_imgs_path(train_pfiles: L, df: pd.DataFrame) -> L:
    """
    Return img Path list of selected df.
    """
    imgId_vals = df["ImageId"].drop_duplicates().values
    path_idx = train_pfiles.argwhere(lambda x: x.name in imgId_vals)
    sel_paths = train_pfiles[path_idx]
    idx = get_random_idx(len(sel_paths))
    return sel_paths[idx]

# Cell
def plot_defected_image(img_path: str, df: pd.DataFrame = train):
    """
    Plot image with segmented area
    """
    def color(x, y, classid):
        if classid == 4:
            im[y, x, 1] += 50
            im[y, x, 2] += 50
        else:
            im[y, x, classid-1] += 50

    def plot(im, imgid, classids):
        clip_im = np.clip(im, 0, 255)
        title = "ImageId: {} - ClassId: {}".format(
            imgid, " ".join(map(str, classids)))

        plt.figure(figsize=(25, 5))
        plt.imshow(clip_im)
        plt.xticks([])
        plt.yticks([])
        plt.title(title, fontsize=20)
        plt.show()

    im = np.array(Image.open(img_path))

    img_id = img_path.name
    df = df.loc[df["ImageId"] == img_id]

    classids = []
    for img in df.itertuples(index=False):
        classids.append(img.ClassId)
        classid = img.ClassId

        x, y = defeat_position(img_id, classid)

        color(x, y, classid)

    plot(im, img_id, classids)

# Cell
def show_defects(class_id=None, n=20, only_defects=True, multi_defects=False):
    """
    Plot multiple images.
    Attributes:
    `class_id`: [str or int] select a type of defect otherwise plot all kinds;
    `n`: select the number of images to plot;
    `only_defects` [bool, default True]: if False it shows even the no faulty images;
    `multi_defects` [bool, default False]: if True it shows imgs with multi defects.
    """
    df = train_multi

    cond_no_defects = df["ClassId_multi"] == '0'
    cond_multi_defects = df["ClassId_multi"].map(lambda x: len(x) > 1)
    cond_classId = df["ClassId_multi"].map(lambda x: str(class_id) in x)

    df = df.loc[cond_no_defects] if not only_defects else df.loc[~cond_no_defects]
    df = df.loc[cond_multi_defects] if multi_defects else df.loc[~cond_multi_defects]
    df = df.loc[cond_classId] if class_id else df

    imgid_from_df = df["ImageId"].tolist()
    pfiles_list = L([train_path / imgid for imgid in imgid_from_df])

    perm_paths = get_perm_imgs_path(pfiles_list, df)
    for img_path in perm_paths[:n]:
        plot_defected_image(img_path)

# Cell
def rle_to_mask(rle: str, class_id: int, height: int, width: int) -> np.ndarray:
    """
    Convert RLE encoded pixels to numpy array for only one class_id
    """
    rows, cols = height, width
    mask = np.zeros(rows*cols, dtype=np.uint8)

    if rle == -1:
        return mask.reshape(cols, rows).T

    encoded_pixels = [int(i) for i in rle.split(" ")]

    # (n, 2) as [[pos, offs], ... ]
    rle_pairs = np.array(encoded_pixels).reshape(-1, 2)

    for index, length in rle_pairs:
        index -= 1
        mask[index: (index + length)] = class_id

    mask = mask.reshape(cols, rows)
    return mask.T

# Cell
def multi_rle_to_mask(img_path: str, df: pd.DataFrame = train_all) -> np.ndarray:
    """
    Convert all RLE encoded pixels for an image and returns the mask
    """
    height, width = 256, 1600

    def build_mask(df) -> np.ndarray:
        masks = defaultdict(np.ndarray)
        for num, row in enumerate(df.itertuples()):
            masks[num] = rle_to_mask(
                row.EncodedPixels, row.ClassId, height, width)

        mask = masks.pop(0)

        items_left = len(masks)
        if items_left:
            for item in range(items_left):
                mask_to_add = masks.get(item + 1)
                mask = np.add(mask, mask_to_add)

        return mask

    img_id = img_path.name
    img_df = df.loc[df["ImageId"] == img_id]
    return build_mask(img_df)

# Cell
def img_with_mask(img_path: str):
    return np.array(Image.open(img_path)), multi_rle_to_mask(img_path)

# Cell
def mask2rle(img):
    '''
    From #https://www.kaggle.com/paulorzp/rle-functions-run-lenght-encode-decode

    Attributes: `img`: numpy array, 1 -> mask, 0 -> background.

    Returns: run length as string formated
    '''
    pixels= img.T.flatten()
    pixels = np.concatenate([[0], pixels, [0]])
    runs = np.where(pixels[1:] != pixels[:-1])[0] + 1
    runs[1::2] -= runs[::2]
    return ' '.join(str(x) for x in runs)

# Cell
def make_mask(row_id, df=train_pivot):
    '''
    Given a row index, return image_id and mask (256, 1600, 4)
    from the dataframe `df`
    '''
    if isinstance(row_id, str):    cond = df.loc[row_id]
    elif isinstance(row_id, int):  cond = df.iloc[row_id]
    elif isinstance(row_id, Path): cond = df.loc[row_id.name]
    elif isinstance(row_id, pd.Series):
        cond = df.loc[row_id["ImageId"]]
    else:
        print(row_id, type(row_id))
        raise KeyError("row_id must be int or str")

    fname = cond.name
    labels = cond[1:-1] # only 1,2,3,4 ClassId

    # float32 is V.Imp 4:class 1～4 (ch:0～3)
    masks = np.zeros((256, 1600, 4), dtype=np.float32)

    for idx, label in enumerate(labels.values):
        if label is not np.nan:
            label = label.split(" ")
            positions = map(int, label[0::2])
            length = map(int, label[1::2])
            mask = np.zeros(256 * 1600, dtype=np.uint8)
            for pos, le in zip(positions, length):
                mask[pos:(pos + le)] = 1
            masks[:, :, idx] = mask.reshape(256, 1600, order='F')

    return fname, masks

# Cell
labels_path = path / "labels"

def create_masks(df: pd.DataFrame):
    """Create the masks for ImageId in df"""
    paths = []
    for img_id in df["ImageId"].tolist():
        img_path = train_path / img_id
        img_label = labels_path/f"{img_path.stem}_P.png"
        if not img_label.is_file():
            mask = multi_rle_to_mask(img_path)
            im = Image.fromarray(mask)
            im.save(img_label)
        paths.append(img_label)
    return L(paths)